/*
 ****************************************************************
 * Mach Operating System
 * Copyright (c) 1986 Carnegie-Mellon University
 *  
 * This software was developed by the Mach operating system
 * project at Carnegie-Mellon University's Department of Computer
 * Science. Software contributors as of May 1986 include Mike Accetta, 
 * Robert Baron, William Bolosky, Jonathan Chew, David Golub, 
 * Glenn Marcy, Richard Rashid, Avie Tevanian and Michael Young. 
 * 
 * Some software in these files are derived from sources other
 * than CMU.  Previous copyright and other source notices are
 * preserved below and permission to use such software is
 * dependent on licenses from those institutions.
 * 
 * Permission to use the CMU portion of this software for 
 * any non-commercial research and development purpose is
 * granted with the understanding that appropriate credit
 * will be given to CMU, the Mach project and its authors.
 * The Mach project would appreciate being notified of any
 * modifications and of redistribution of this software so that
 * bug fixes and enhancements may be distributed to users.
 *
 * All other rights are reserved to Carnegie-Mellon University.
 ****************************************************************
 */
/*
 * 5799-CGZ (C) COPYRIGHT IBM CORPORATION  1986
 * LICENSED MATERIALS - PROPERTY OF IBM
 * REFER TO COPYRIGHT INSTRUCTIONS FORM NUMBER G120-2083
 */
/* $Header: asy.c,v 5.1 86/02/19 07:18:42 derrick Exp $ */
/* $Source: /ibm/acis/usr/sys_ca/caio/RCS/asy.c,v $ */

/*
 * Multiport asynchronous driver
 */
#include "asy.h"
#if NASY > 0
#include "../ca/ioctl.h"
#include "../h/param.h"
#include "../h/conf.h"
#include "../h/dir.h"
#include "../h/user.h"
#include "../h/proc.h"
#include "../h/ioctl.h"
#include "../h/tty.h"
#include "../h/systm.h"
#include "../h/uio.h"
#include "../h/file.h"
#include "../ca/debug.h"

#include "../caio/asyregs.h"
#include "../ca/io.h"
#include "../h/buf.h"
#include "../caio/ioccvar.h"
#include "../caio/apdefs.h"
/*
 * Encoding of the minor device number:
 * Bits 0 and 1  encode the unit number (0-3) on the multiport adaptor
 * Bits 2,3 and 4 encode the adaptor number: 0-3 for multiport adaptors
 *                                             4 for COM1
 *                                             
 */

#define SETBAUD(r, b)	r->ASY_LCR |= LCR_DLAB;\
			r->ASY_DLLSB = asybaudtbl[b].lsb;\
			r->ASY_DLMSB = asybaudtbl[b].msb;\
			r->ASY_LCR &= ~LCR_DLAB;

static struct asybaudtbl {
	unsigned char msb;
	unsigned char lsb;
} asybaudtbl [NSPEEDS] = {
/* B0 */	0x00, 0x00,
/* B50 */	0x09, 0x00,
/* B75 */	0x06, 0x00,
/* B110 */	0x04, 0x17,
/* B134 */	0x03, 0x5B,
/* B150 */	0x03, 0x00,
/* B200 */	0x02, 0x40,
/* B300 */	0x01, 0x80,
/* B600 */	0x00, 0xC0,
/* B1200 */	0x00, 0x60,
/* B1800 */	0x00, 0x40,
/* B2400 */	0x00, 0x30,
/* B4800 */	0x00, 0x18,
/* B9600 */	0x00, 0x0C,
/* EXTA */	0x00, 0x06,	/* 19200 */
/* EXTB */	0x00, 0x00

} ;

/* following taken from hd.c */
#define	SHOW_CHARS	0x01
#define SHOW_RDWR	0x02
#define SHOW_INTR	0x04
#define SHOW_INIT	0x08
#define SHOW_IO		0x10
#define SHOW_WAIT	0x20	/* show wait */
#define SHOW_REGS	0x40
#define SHOW_OPEN	0x80

#define ISPEED B9600	/* default speed */
#define NPORT	4	/* number of serial port per multiport card */
#define OFFSET	8	/* Offset of sets of registers per port */
struct	tty	asy[NASY*NPORT];

int	asyoutc();
int	asystart();
int	ttrstrt();
int	asyatach();
int	asyprobe();
int	asyint();

/* following is a hokey test for a quad card */
#define isquad(addr) (0x0000f000 & (int) (addr) )

/* define standard addresses for autoconf */
caddr_t asystd[] = {
	(caddr_t) 0xf0001230,	/* Multiport adaptor 1 */
	(caddr_t) 0xf0002230,	/* Multiport adaptor 2 */
	(caddr_t) 0xf0003230,	/* Multiport adaptor 3 */
	(caddr_t) 0xf0004230, 	/* Multiport adaptor 4 */
	0 };

#define BADD_ADDR (caddr_t) 0xeeeeeeee	/* to catch bad IRQ number */

caddr_t asyreset[16] = {
	BADD_ADDR, BADD_ADDR, BADD_ADDR, BADD_ADDR,	/* 0 - 3 */
	BADD_ADDR, BADD_ADDR, BADD_ADDR, BADD_ADDR,	/* 4 - 7 */
	BADD_ADDR, (caddr_t)  0xf00002f2,
 	(caddr_t)  0xf00006f2, (caddr_t)  0xf00006f3,	/* 8 - 11 */
	BADD_ADDR, BADD_ADDR, BADD_ADDR, BADD_ADDR,	/* 12 - 15 */
	};

static int overrun_error[NASY*NPORT];
static int parity_error[NASY*NPORT];
struct	iocc_device *asydinfo[NASY];

/*  software carrier detect  */
char asysoftCAR [NASY];    

struct iocc_driver asydriver = { asyprobe, 0, asyatach, 0, asystd,
	"asy", asydinfo, 0, 0, asyint };

/****************************************************************************
The asyprobe will try to generate an interrupt so that the system finds out
if the specific async adaptors ( the ones specified in the config file) are
present, and is so what interrupt level (IRQ) they interrupt.
The interrupt is generated by the loopback feature the INS8250 provides.
****************************************************************************/
asyprobe(addr)
register caddr_t addr;
{

	register ASYDEVICE asyp = (ASYDEVICE) addr;
	char saviir,save;
	int i,j;
	
	DEBUGF(ttydebug,printf("asyprobe(%x)\n",addr));

	if (isquad(addr))
	{		
		for (j=0;j< NPORT;j++)
			{
			 asyp = (ASYDEVICE) addr+j* OFFSET;
			asyp->ASY_SCR = 0xFF; /* FF in scratch reg */
			saviir=	asyp->ASY_IIR ; /* read ASY_IIR */
	DEBUGF(ttydebug,printf(" serial # %d= ASY_IIR[%x]= %x \n",j,addr+2+j*8, saviir));
		
			}
		asyp = (ASYDEVICE) addr;
		saviir=	asyp->ASY_SCR; /* read interrupt pending reg */
		DEBUGF(ttydebug,printf(" Multiport   IPR[%x]= %x \n",addr+7, saviir));
	

		/* reset all interrupt */
		*asyreset[9]=0;
		*asyreset[10]=0;
		*asyreset[11]=0;

	}
	save =asyp->ASY_LSR;
	DEBUGF(ttydebug,printf(" ASY_LSR= %x ",save));
	save =asyp->ASY_MSR;
	DEBUGF(ttydebug,printf(" ASY_MSR= %x \n",save));
	asyp->ASY_LCR = LCR_8BIT;
	asyp->ASY_IER = IER_MSR;		/* enable modem status int. */
	asyp->ASY_MCR = MCR_OUT2 ;
	asyp->ASY_MCR = MCR_OUT2 | MCR_LOOP | MCR_RTS;
	asyp->ASY_MCR = MCR_OUT2 | MCR_LOOP  ;
	asyp->ASY_MCR = MCR_OUT2 ;
	DELAY(10000);
	DEBUGF(ttydebug,printf("asyprobe - ASY_IIR[%x] =%x \n",&(asyp->ASY_IIR),asyp->ASY_IIR));
	asyp->ASY_IER=0;	/* disable all int*/
	saviir= asyp->ASY_MSR;	/* reset int. reg */
DEBUGF(ttydebug,printf("asyprobe - ASY_MSR[%x] =%x \n",&(asyp->ASY_MSR),saviir));
	if ( isquad(addr)){
		*asyreset[9]=0;	
		*asyreset[10]=0;
		*asyreset[11]=0;  
		PROBE_DELAY(10000);
	};
	return(PROBE_OK);
}
 
asyatach (iod)
register struct iocc_device *iod;
{
	register struct tty *tp;
	register int ctlr = iod->iod_unit;
	register ASYDEVICE addr = (ASYDEVICE) iod->iod_addr;
	register  int  ctlr_num = ctlr <<2 ;
	register int subunit	;		/* 0-4 */


	DEBUGF(ttydebug & SHOW_INIT, printf("in asyatach ctlr=%d addr=%x\n",
		ctlr,addr));

DEBUGF(ttydebug, printf("ctlr= %x \n",ctlr));
	for (subunit=0 ;subunit <NPORT;subunit++, ++addr)
	{
		tp = &asy[ctlr_num+subunit];
		tp->t_addr = (caddr_t) addr;
		tp->t_state = 0;
		if ( !isquad(addr))
			break;		/* only per PC card */
	};
	asysoftCAR[iod->iod_unit]= iod->iod_flags; /* carrier detect */
}

/*ARGSUSED*/
asyopen(dev, flag)
	dev_t dev;
{
	register struct tty *tp;
	register int unit = minor (dev);
	register int s;
	register ASYDEVICE asyadr ;
	register struct iocc_device  *iod;
	register char flushchar;
	int adapter = unit >>2 ;  /* lower 2 bits encode the port number */

	DEBUGF(ttydebug & SHOW_OPEN, printf ("In ASYOPEN unit=%x\n",unit));
	if (unit >= NASY*NPORT || ( iod = asydinfo[adapter])  == 0 || iod->iod_alive
             ==0)
		return (ENXIO);
	overrun_error[unit] =0; /* clear error counters */
	parity_error[unit] = 0;
	tp = &asy[unit];
	asyadr = (ASYDEVICE)tp->t_addr;
	tp->t_oproc = asystart;
	tp->t_state |= TS_WOPEN; 

/* if this is first open, initialize tty state to defaults */

	if ((tp->t_state&TS_ISOPEN) == 0) {
		ttychars(tp);
		tp->t_ospeed = tp->t_ispeed = ISPEED;
		tp->t_flags = ODDP|EVENP|ECHO;
		asyparam (unit);
		s= ASYSPL();
		/* turn DTR RTS on */
		asyadr-> ASY_MCR = MCR_OUT2|MCR_DTR|MCR_RTS; 

		/* enable receive ,line and modem interrupts */
	 	asyadr->ASY_IER = IER_DR | IER_LSR | IER_MSR ; 
		(void) splx(s);
	}

	if (tp->t_state&TS_XCLUDE && u.u_uid != 0)
		return (EBUSY);
	/* turn DTR RTS on */
	asyadr-> ASY_MCR = MCR_OUT2|MCR_DTR|MCR_RTS; 
	
	/* check if modem control is on or the carrier is up */

	if ((( asyadr->ASY_MSR) & MSR_RLSD  ) ||
		 asysoftCAR[adapter] & (1 << (unit & 0x3))) 
		tp->t_state |= TS_CARR_ON;
        s= ASYSPL();
/* wait for carrier to come up. ( could be forever... no timeouts ???) */

        while ((tp->t_state & TS_CARR_ON) == 0) {
                tp->t_state |= TS_WOPEN;
                sleep((caddr_t)&tp->t_rawq, TTIPRI);
        }
        (void) splx(s);

	DEBUGF(ttydebug & SHOW_OPEN, printf ("ASYOPEN: call ttyopen (%x)\n", linesw[tp->t_line].l_open));
	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

/*ARGSUSED*/
asyclose(dev)
	dev_t dev;
{
	register int unit = minor(dev);
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr = (ASYDEVICE)tp->t_addr;

	DEBUGF(ttydebug & SHOW_OPEN, printf ("In ASYCLOSE\n"));


	(*linesw[tp->t_line].l_close)(tp);
	asyadr->ASY_LCR &= ~ LCR_SETB; /* clear break */
	if ((tp->t_state&TS_WOPEN|TS_HUPCLS) || (tp->t_state&TS_ISOPEN) == 0)
		{
	 	asyadr->ASY_IER =~( IER_DR | IER_LSR | IER_MSR) ; 
		asyadr->ASY_MCR =MCR_OUT2;
		}

	ttyclose(tp);
	DEBUGF(ttydebug & SHOW_OPEN, printf ("ASYCLOSE end\n"));
}

/*ARGSUSED*/
asyread(dev, uio)
	register dev_t dev;
	register struct uio *uio;
{
	register struct tty *tp = &asy[minor(dev)];
	DEBUGF(ttydebug & SHOW_RDWR, {
	register ASYDEVICE asyadr = (ASYDEVICE)tp->t_addr;

	printf ("In ASYREAD\n");
	printf ("asyadr (%x) ASY_LCR (%x) ASY_IER (%x)\n", asyadr,
		asyadr->ASY_LCR, asyadr->ASY_IER);
});
	return ((*linesw[tp->t_line].l_read)(tp, uio));
}

/*ARGSUSED*/
asywrite(dev, uio)
	dev_t dev;
	struct uio *uio;
{
	register struct tty *tp = &asy[minor(dev)];

	DEBUGF(ttydebug & SHOW_RDWR, printf ("In ASYWRITE\n"));
	return ((*linesw[tp->t_line].l_write)(tp, uio));
}
/*ARGSUSED*/
asyrint(unit)
	register int unit;
{
	register int c;
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr = (ASYDEVICE)tp->t_addr;
	register struct iocc_device  *iod;
	register char savelsr;


	DEBUGF(ttydebug & SHOW_INTR, printf ("In ASYRINT\n"));
	if (( iod = asydinfo[unit >> 2 ])  == 0 || iod->iod_alive ==0) return;
	while ((savelsr = asyadr->ASY_LSR) & LSR_DR) 
	{
		c = asyadr ->ASY_RXB;
		if ( tp->t_line == APLDISC)
			{
			if  (savelsr & LSR_BI) c= APBREAK;
         		else if ( savelsr & LSR_FE) c=APERROR;
			(*linesw[tp->t_line].l_rint)(c, tp);
			}
		else 
		{	
			
		if ((tp->t_state & TS_ISOPEN) == 0) 
			{
			wakeup((caddr_t)&tp->t_rawq);
			continue;
			}
		if (savelsr & LSR_PE)
			{
			if (((tp->t_flags & (EVENP|ODDP)) == EVENP)
			  || ((tp->t_flags & (EVENP|ODDP)) == ODDP))
				DEBUGF(ttydebug,
					  printf(" asyrint: parity error %d\n",
						++parity_error[unit]));
			continue; 
		/*		goto done */	/* ignore if bad parity */
			}
		/*
		 * A framing error (break) generates
		 * a null ( in raw mode, for getty), or
		 * an interrupt ( in cooked/cbreak modes).
		 */
		if (savelsr & (LSR_FE | LSR_BI))
			if (tp->t_flags & RAW)
				c = 0;
			else
				c = tp->t_intrc;

		if (savelsr & LSR_OR) 
		printf ("asyrint: overrun error %d\n", ++overrun_error[unit] );
		DEBUGF(ttydebug & SHOW_CHARS,printf ("GOT -> (%c) (%x)\n", c, c));
		(*linesw[tp->t_line].l_rint)(c, tp);
		}
	}
done:
	DEBUGF(ttydebug & SHOW_INTR,printf ("asyrint end\n"));
}

/*ARGSUSED*/
/* modeled after dh-11 */
asyioctl(dev, cmd, addr, flag)
	dev_t dev;
	caddr_t addr;
{
	register int unit = minor(dev);
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr = (ASYDEVICE) tp->t_addr;
	register int error, s;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, addr,flag);
	if (cmd == TIOCSETD && *(int *)addr == APLDISC) 
		tp->t_oproc = asyoutc;
	if (error >= 0)
		return (error);
	error = ttioctl(tp, cmd, addr, flag);
	if (error >= 0) {
		if (cmd == TIOCSETP || cmd == TIOCSETN) {
			asyparam(unit);
		}
		return (error);
	}
	s= ASYSPL();
	switch (cmd) {
	case TIOCSBRK:	/* Set break */
		asyadr->ASY_LCR |= LCR_SETB;
		break;
	case TIOCCBRK:	/* Clear break */
		asyadr->ASY_LCR &= ~ LCR_SETB;
		break;
	case TIOCSDTR:	/* Set DTR  and RTS */
		asyadr->ASY_MCR =MCR_DTR|MCR_RTS|MCR_OUT2;
		break;
	case TIOCCDTR:	/* Clear DTR and RTS */
		asyadr->ASY_MCR =MCR_OUT2;
		break;
	default:
		(void) splx(s);
		return (ENOTTY);
	}
	(void) splx(s);
	return (0);

}

/*ARGSUSED*/
asyxint(unit)
	register int unit;
{
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr= (ASYDEVICE)tp->t_addr;

	DEBUGF(ttydebug & SHOW_INTR,printf ("In ASYXINT\n"));
	if (tp->t_line == APLDISC)
{
	DEBUGF(ttydebug & SHOW_INTR,printf ("calling line disc \n"));
		(*linesw[tp->t_line].l_start)(tp);
}
	else
	{
	tp->t_state &= ~TS_BUSY;
	if (tp->t_outq.c_cc <= 0) {
		/* NO CHARACTERS IN QUEUE SO WHY INTERRUPT??? */
		/* Let asystart turn on interrupts if it has to */
		asyadr->ASY_IER &= ~(IER_THRE);
	}
	if (tp->t_line)
		(*linesw[tp->t_line].l_start)(tp);
	else
		asystart(tp);
	}
	DEBUGF(ttydebug & SHOW_INTR, printf ("asyxint end\n"));
}

asystart(tp)
	register struct tty *tp;
{
	register ASYDEVICE asyadr= (ASYDEVICE)tp->t_addr;
	register int c, s;
	register int unit = minor(tp->t_dev);

	DEBUGF(ttydebug & SHOW_IO, printf ("In ASYSTART\n"));
	/*
	 * Must hold interrupts to prevent state of the tp
	 * from changing
	 */
	s= ASYSPL();
	/*
	 * if  it's currently active, or delaying, no need to do anything.
         */
	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out2;
	/*
	 * if there are sleepers, and output has drained below  low
	 * water mark, wake up sleepers.
         */

	if (tp->t_outq.c_cc <= TTLOWAT(tp)) {
		if (tp->t_state&TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		if (tp->t_wsel) {
			selwakeup(tp->t_wsel, tp->t_state & TS_WCOLL);
			tp->t_wsel = 0;
			tp->t_state &= ~TS_WCOLL;
		}
	}
	while (asyadr->ASY_LSR & LSR_THRE) {
		if ((tp->t_outq.c_cc <= 0) || (c = getc(&tp->t_outq)) == -1) {
			goto out;
		}

	DEBUGF(ttydebug & SHOW_CHARS,
		printf ("put (%c) (%x)\n", (char) (c&0xff), (char)(c&0xff)));
		if (tp->t_flags&(RAW|LITOUT)) {
			asyadr->ASY_TXB = (char) c;
			
		} else if (c <= 0177) {
			asyadr->ASY_TXB = (char) c;
		} else {
			timeout(ttrstrt, (caddr_t)tp, (c&0177));
			tp->t_state |= TS_TIMEOUT;
	DEBUGF(ttydebug & SHOW_CHARS, 	printf ("asystart timeout\n"));
			goto out;
		}
	}

		tp->t_state |= TS_BUSY;
		asyadr->ASY_IER |= (IER_THRE);
		goto out2;	
out:	
		asyadr->ASY_IER &= ~(IER_THRE);
		tp->t_state &= ~TS_BUSY;
out2:	(void) splx(s);
	DEBUGF(ttydebug & SHOW_IO, printf (" asystart end\n"));
}


asyparam (unit)
register int unit;
{
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr = (ASYDEVICE) tp->t_addr;
	register char apr;
	register char flushchar;
	register int s;

	DEBUGF(ttydebug&SHOW_IO, {printf ("In ASYPARAM\n");
	printf ("tp->t_flags = (%x)\n", tp->t_flags);});
	if (tp->t_ispeed == B0) 
		{
		tp->t_state |= TS_HUPCLS;
		asyadr->ASY_MCR = MCR_OUT2;	/* hang up line ( DTR,RTS =0) */
		return;
		}
	s= ASYSPL();

	/* Set the baud rate and initial async settings */
	SETBAUD(asyadr, tp->t_ispeed);
	if (tp->t_flags & (RAW|LITOUT))
		apr = LCR_8BIT;
	else
		apr = (LCR_7BIT | LCR_PEN | LCR_STP);
	if (tp->t_flags & EVENP)
		apr |= LCR_EPS;
	if (tp->t_ispeed == B110)
		apr |= LCR_STB;
	asyadr->ASY_LCR = apr;


	DEBUGF(ttydebug & SHOW_REGS,printf (" after ASY_IER (%x)", asyadr->ASY_IER));
	DEBUGF(ttydebug & SHOW_IO, printf (" asyparam end\n"));
	(void) splx(s);
}

/*
 * unit indicates which of 4 line unit caused the interrupt
 */


asyint (ctlr, icscs)
register int ctlr;
register int icscs;
{
	register unsigned char port;
	register int unit = ctlr << 2;
	register ASYDEVICE asyaddr = (ASYDEVICE) asydinfo[ctlr]->iod_addr;


	if (isquad(asyaddr))
		{
		port = asyaddr -> scr;
		if ( port & PORT_A ) { asy_u_int(unit+0,icscs);};
		if ( port & PORT_B ) { asy_u_int(unit+1,icscs);};
		if ( port & PORT_C ) { asy_u_int(unit+2,icscs);};
		if ( port & PORT_D ) { asy_u_int(unit+3,icscs);};
		* asyreset[asydinfo[ctlr]->iod_irq & 0xf] = 0;
		return((port & (PORT_A|PORT_B|PORT_C|PORT_D)) == 0);
		}
	else
		return(asy_u_int(unit,icscs));	/* it will tell caller */
}



/* per port interrupt */

asy_u_int (unit, icscs)
register int unit;
register int icscs;
{
	register dev_t dev;
	register ASYDEVICE asyadr;
	register unsigned char saveiir;


	DEBUGF(ttydebug & SHOW_INTR,printf ("In ASYINT unit (%x)\n", unit));

	asyadr = (ASYDEVICE) (asy[unit].t_addr);
	while(((saveiir = asyadr->ASY_IIR) & IIR_PEND) == 0)
	{

	switch (saveiir & IIR_MASK) {
		case IIR_LSR:
		case IIR_RXB:
			asyrint (unit);
			break;
		case IIR_TXB:
			asyxint (unit);
			break;
		case IIR_MSR:
			asymint (unit);
			break;
		default:
			printf("In ASYINT unit (%x) Interrupt = %x\n",unix,saveiir);
			break;

	}
	} 
return(0);
}

asymint(unit)
	register int unit;
{
	register struct tty *tp = &asy[unit];
	register ASYDEVICE asyadr = (ASYDEVICE)tp->t_addr;
	register char savemsr;

	DEBUGF(ttydebug & SHOW_INTR, printf ("In ASYMINT\n"));

	savemsr = asyadr ->ASY_MSR;
	if ( tp->t_line == APLDISC) 
		return(0);
	if  (savemsr & MSR_DRLSD)	/* if carrier transition */
		{
		if ( savemsr & MSR_RLSD) /* if carrier on */
			{
			if ((tp->t_state & TS_CARR_ON) == 0)
				{
				wakeup((caddr_t)&tp->t_rawq);
				tp->t_state |= TS_CARR_ON;
				}
			}
		else
			{
			if (tp->t_state & TS_CARR_ON) 
				{
		   		gsignal (tp-> t_pgrp, SIGHUP);
		 		gsignal (tp-> t_pgrp, SIGCONT);
				ttyflush(tp,FREAD|FWRITE);
				}				
			tp->t_state &= ~ TS_CARR_ON;
			}


		}
return(0);
}

/* This routine is for the support of the 3812 printer. It will do one of three
 * functions  1) set the break bit 2) clear the break bit  3) output one 
 * character.
 */
asyoutc(tp,c)
	register struct tty *tp;
	register int c;
{
	register ASYDEVICE asyadr = (ASYDEVICE)tp->t_addr;

	if (c >= 0)
		asyadr->ASY_TXB = (char) c;
	else {
		switch (c) {
		case APBREAKON:
			asyadr->ASY_LCR |= LCR_SETB;
			break;
		case APBREAKOFF:
			asyadr->ASY_LCR &= ~ LCR_SETB;
			break;
		case APINTMASK:
			asyadr->ASY_IER = IER_LSR | IER_THRE | IER_DR;
			break;
		}
	}
}
#endif NASY
